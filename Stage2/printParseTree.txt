
Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
program $ 

Top of stack: program | Input Token: DRIVERDEF | Input Token Lexeme: <<<
Entry exists in Parse Table
Rule no to use in grammar.txt: 1 | X = 0 | a-NTER = 2 

Pushing these on stack now: 
otherModules 
driverModule 
otherModules 
moduleDeclarations 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
moduleDeclarations otherModules driverModule otherModules $ 

Top of stack: moduleDeclarations | Input Token: DRIVERDEF | Input Token Lexeme: <<<
Entry exists in Parse Table
Rule no to use in grammar.txt: 3 | X = 1 | a-NTER = 2 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
otherModules driverModule otherModules $ 

Top of stack: otherModules | Input Token: DRIVERDEF | Input Token Lexeme: <<<
Entry exists in Parse Table
Rule no to use in grammar.txt: 6 | X = 3 | a-NTER = 2 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
driverModule otherModules $ 

Top of stack: driverModule | Input Token: DRIVERDEF | Input Token Lexeme: <<<
Entry exists in Parse Table
Rule no to use in grammar.txt: 7 | X = 4 | a-NTER = 2 

Pushing these on stack now: 
moduleDef 
DRIVERENDDEF 
PROGRAM 
DRIVER 
DRIVERDEF 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
DRIVERDEF DRIVER PROGRAM DRIVERENDDEF moduleDef otherModules $ 

Top of stack: DRIVERDEF | Input Token: DRIVERDEF | Input Token Lexeme: <<<
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
DRIVER PROGRAM DRIVERENDDEF moduleDef otherModules $ 

Top of stack: DRIVER | Input Token: DRIVER | Input Token Lexeme: driver
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
PROGRAM DRIVERENDDEF moduleDef otherModules $ 

Top of stack: PROGRAM | Input Token: PROGRAM | Input Token Lexeme: program
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
DRIVERENDDEF moduleDef otherModules $ 

Top of stack: DRIVERENDDEF | Input Token: DRIVERENDDEF | Input Token Lexeme: >>>
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
moduleDef otherModules $ 

Top of stack: moduleDef | Input Token: START | Input Token Lexeme: start
Entry exists in Parse Table
Rule no to use in grammar.txt: 25 | X = 14 | a-NTER = 11 

Pushing these on stack now: 
END 
statements 
START 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
START statements END otherModules $ 

Top of stack: START | Input Token: START | Input Token Lexeme: start
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statements END otherModules $ 

Top of stack: statements | Input Token: DECLARE | Input Token Lexeme: declare
Entry exists in Parse Table
Rule no to use in grammar.txt: 26 | X = 15 | a-NTER = 0 

Pushing these on stack now: 
statements 
statement 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statement statements END otherModules $ 

Top of stack: statement | Input Token: DECLARE | Input Token Lexeme: declare
Entry exists in Parse Table
Rule no to use in grammar.txt: 30 | X = 16 | a-NTER = 0 

Pushing these on stack now: 
declareStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
declareStmt statements END otherModules $ 

Top of stack: declareStmt | Input Token: DECLARE | Input Token Lexeme: declare
Entry exists in Parse Table
Rule no to use in grammar.txt: 93 | X = 49 | a-NTER = 0 

Pushing these on stack now: 
SEMICOL 
dataType 
COLON 
idList 
DECLARE 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
DECLARE idList COLON dataType SEMICOL statements END otherModules $ 

Top of stack: DECLARE | Input Token: DECLARE | Input Token Lexeme: declare
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
idList COLON dataType SEMICOL statements END otherModules $ 

Top of stack: idList | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 54 | X = 29 | a-NTER = 5 

Pushing these on stack now: 
idList_again 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID idList_again COLON dataType SEMICOL statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: num
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
idList_again COLON dataType SEMICOL statements END otherModules $ 

Top of stack: idList_again | Input Token: COMMA | Input Token Lexeme: ,
Entry exists in Parse Table
Rule no to use in grammar.txt: 55 | X = 30 | a-NTER = 6 

Pushing these on stack now: 
idList_again 
ID 
COMMA 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
COMMA ID idList_again COLON dataType SEMICOL statements END otherModules $ 

Top of stack: COMMA | Input Token: COMMA | Input Token Lexeme: ,
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID idList_again COLON dataType SEMICOL statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: k
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
idList_again COLON dataType SEMICOL statements END otherModules $ 

Top of stack: idList_again | Input Token: COLON | Input Token Lexeme: :
Entry exists in Parse Table
Rule no to use in grammar.txt: 56 | X = 30 | a-NTER = 48 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
COLON dataType SEMICOL statements END otherModules $ 

Top of stack: COLON | Input Token: COLON | Input Token Lexeme: :
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
dataType SEMICOL statements END otherModules $ 

Top of stack: dataType | Input Token: INTEGER | Input Token Lexeme: integer
Entry exists in Parse Table
Rule no to use in grammar.txt: 17 | X = 11 | a-NTER = 7 

Pushing these on stack now: 
INTEGER 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
INTEGER SEMICOL statements END otherModules $ 

Top of stack: INTEGER | Input Token: INTEGER | Input Token Lexeme: integer
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SEMICOL statements END otherModules $ 

Top of stack: SEMICOL | Input Token: SEMICOL | Input Token Lexeme: ;
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statements END otherModules $ 

Top of stack: statements | Input Token: DECLARE | Input Token Lexeme: declare
Entry exists in Parse Table
Rule no to use in grammar.txt: 26 | X = 15 | a-NTER = 0 

Pushing these on stack now: 
statements 
statement 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statement statements END otherModules $ 

Top of stack: statement | Input Token: DECLARE | Input Token Lexeme: declare
Entry exists in Parse Table
Rule no to use in grammar.txt: 30 | X = 16 | a-NTER = 0 

Pushing these on stack now: 
declareStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
declareStmt statements END otherModules $ 

Top of stack: declareStmt | Input Token: DECLARE | Input Token Lexeme: declare
Entry exists in Parse Table
Rule no to use in grammar.txt: 93 | X = 49 | a-NTER = 0 

Pushing these on stack now: 
SEMICOL 
dataType 
COLON 
idList 
DECLARE 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
DECLARE idList COLON dataType SEMICOL statements END otherModules $ 

Top of stack: DECLARE | Input Token: DECLARE | Input Token Lexeme: declare
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
idList COLON dataType SEMICOL statements END otherModules $ 

Top of stack: idList | Input Token: ID | Input Token Lexeme: A
Entry exists in Parse Table
Rule no to use in grammar.txt: 54 | X = 29 | a-NTER = 5 

Pushing these on stack now: 
idList_again 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID idList_again COLON dataType SEMICOL statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: A
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
idList_again COLON dataType SEMICOL statements END otherModules $ 

Top of stack: idList_again | Input Token: COLON | Input Token Lexeme: :
Entry exists in Parse Table
Rule no to use in grammar.txt: 56 | X = 30 | a-NTER = 48 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
COLON dataType SEMICOL statements END otherModules $ 

Top of stack: COLON | Input Token: COLON | Input Token Lexeme: :
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
dataType SEMICOL statements END otherModules $ 

Top of stack: dataType | Input Token: ARRAY | Input Token Lexeme: array
Entry exists in Parse Table
Rule no to use in grammar.txt: 20 | X = 11 | a-NTER = 10 

Pushing these on stack now: 
type 
OF 
SQBC 
range_arrays 
SQBO 
ARRAY 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ARRAY SQBO range_arrays SQBC OF type SEMICOL statements END otherModules $ 

Top of stack: ARRAY | Input Token: ARRAY | Input Token Lexeme: array
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SQBO range_arrays SQBC OF type SEMICOL statements END otherModules $ 

Top of stack: SQBO | Input Token: SQBO | Input Token Lexeme: [
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
range_arrays SQBC OF type SEMICOL statements END otherModules $ 

Top of stack: range_arrays | Input Token: NUM | Input Token Lexeme: 1
Entry exists in Parse Table
Rule no to use in grammar.txt: 21 | X = 12 | a-NTER = 20 

Pushing these on stack now: 
index 
RANGEOP 
index 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
index RANGEOP index SQBC OF type SEMICOL statements END otherModules $ 

Top of stack: index | Input Token: NUM | Input Token Lexeme: 1
Entry exists in Parse Table
Rule no to use in grammar.txt: 49 | X = 26 | a-NTER = 20 

Pushing these on stack now: 
NUM 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
NUM RANGEOP index SQBC OF type SEMICOL statements END otherModules $ 

Top of stack: NUM | Input Token: NUM | Input Token Lexeme: 1
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
RANGEOP index SQBC OF type SEMICOL statements END otherModules $ 

Top of stack: RANGEOP | Input Token: RANGEOP | Input Token Lexeme: ..
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
index SQBC OF type SEMICOL statements END otherModules $ 

Top of stack: index | Input Token: NUM | Input Token Lexeme: 10
Entry exists in Parse Table
Rule no to use in grammar.txt: 49 | X = 26 | a-NTER = 20 

Pushing these on stack now: 
NUM 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
NUM SQBC OF type SEMICOL statements END otherModules $ 

Top of stack: NUM | Input Token: NUM | Input Token Lexeme: 10
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SQBC OF type SEMICOL statements END otherModules $ 

Top of stack: SQBC | Input Token: SQBC | Input Token Lexeme: ]
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
OF type SEMICOL statements END otherModules $ 

Top of stack: OF | Input Token: OF | Input Token Lexeme: of
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
type SEMICOL statements END otherModules $ 

Top of stack: type | Input Token: INTEGER | Input Token Lexeme: integer
Entry exists in Parse Table
Rule no to use in grammar.txt: 22 | X = 13 | a-NTER = 7 

Pushing these on stack now: 
INTEGER 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
INTEGER SEMICOL statements END otherModules $ 

Top of stack: INTEGER | Input Token: INTEGER | Input Token Lexeme: integer
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SEMICOL statements END otherModules $ 

Top of stack: SEMICOL | Input Token: SEMICOL | Input Token Lexeme: ;
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statements END otherModules $ 

Top of stack: statements | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 26 | X = 15 | a-NTER = 5 

Pushing these on stack now: 
statements 
statement 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statement statements END otherModules $ 

Top of stack: statement | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 29 | X = 16 | a-NTER = 5 

Pushing these on stack now: 
simpleStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
simpleStmt statements END otherModules $ 

Top of stack: simpleStmt | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 42 | X = 21 | a-NTER = 5 

Pushing these on stack now: 
assignmentStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
assignmentStmt statements END otherModules $ 

Top of stack: assignmentStmt | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 44 | X = 22 | a-NTER = 5 

Pushing these on stack now: 
whichStmt 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID whichStmt statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: num
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
whichStmt statements END otherModules $ 

Top of stack: whichStmt | Input Token: ASSIGNOP | Input Token Lexeme: :=
Entry exists in Parse Table
Rule no to use in grammar.txt: 45 | X = 23 | a-NTER = 21 

Pushing these on stack now: 
lvalueIDStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
lvalueIDStmt statements END otherModules $ 

Top of stack: lvalueIDStmt | Input Token: ASSIGNOP | Input Token Lexeme: :=
Entry exists in Parse Table
Rule no to use in grammar.txt: 47 | X = 24 | a-NTER = 21 

Pushing these on stack now: 
SEMICOL 
expression 
ASSIGNOP 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ASSIGNOP expression SEMICOL statements END otherModules $ 

Top of stack: ASSIGNOP | Input Token: ASSIGNOP | Input Token Lexeme: :=
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
expression SEMICOL statements END otherModules $ 

Top of stack: expression | Input Token: NUM | Input Token Lexeme: 5
Entry exists in Parse Table
Rule no to use in grammar.txt: 57 | X = 31 | a-NTER = 20 

Pushing these on stack now: 
arithmeticOrBooleanExpr 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticOrBooleanExpr SEMICOL statements END otherModules $ 

Top of stack: arithmeticOrBooleanExpr | Input Token: NUM | Input Token Lexeme: 5
Entry exists in Parse Table
Rule no to use in grammar.txt: 64 | X = 35 | a-NTER = 20 

Pushing these on stack now: 
arithmeticOrBooleanExpr_again 
recTerm 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
recTerm arithmeticOrBooleanExpr_again SEMICOL statements END otherModules $ 

Top of stack: recTerm | Input Token: NUM | Input Token Lexeme: 5
Entry exists in Parse Table
Rule no to use in grammar.txt: 67 | X = 37 | a-NTER = 20 

Pushing these on stack now: 
recTerm_again 
arithmeticExpr 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticExpr recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END otherModules $ 

Top of stack: arithmeticExpr | Input Token: NUM | Input Token Lexeme: 5
Entry exists in Parse Table
Rule no to use in grammar.txt: 71 | X = 39 | a-NTER = 20 

Pushing these on stack now: 
arithmeticExpr_again 
term 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END otherModules $ 

Top of stack: term | Input Token: NUM | Input Token Lexeme: 5
Entry exists in Parse Table
Rule no to use in grammar.txt: 74 | X = 41 | a-NTER = 20 

Pushing these on stack now: 
term_again 
factor 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
factor term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END otherModules $ 

Top of stack: factor | Input Token: NUM | Input Token Lexeme: 5
Entry exists in Parse Table
Rule no to use in grammar.txt: 78 | X = 43 | a-NTER = 20 

Pushing these on stack now: 
var_id_num 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
var_id_num term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END otherModules $ 

Top of stack: var_id_num | Input Token: NUM | Input Token Lexeme: 5
Entry exists in Parse Table
Rule no to use in grammar.txt: 38 | X = 19 | a-NTER = 20 

Pushing these on stack now: 
NUM 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
NUM term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END otherModules $ 

Top of stack: NUM | Input Token: NUM | Input Token Lexeme: 5
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END otherModules $ 

Top of stack: term_again | Input Token: SEMICOL | Input Token Lexeme: ;
Entry exists in Parse Table
Rule no to use in grammar.txt: 76 | X = 42 | a-NTER = 40 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END otherModules $ 

Top of stack: arithmeticExpr_again | Input Token: SEMICOL | Input Token Lexeme: ;
Entry exists in Parse Table
Rule no to use in grammar.txt: 73 | X = 40 | a-NTER = 40 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END otherModules $ 

Top of stack: recTerm_again | Input Token: SEMICOL | Input Token Lexeme: ;
Entry exists in Parse Table
Rule no to use in grammar.txt: 70 | X = 38 | a-NTER = 40 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticOrBooleanExpr_again SEMICOL statements END otherModules $ 

Top of stack: arithmeticOrBooleanExpr_again | Input Token: SEMICOL | Input Token Lexeme: ;
Entry exists in Parse Table
Rule no to use in grammar.txt: 66 | X = 36 | a-NTER = 40 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SEMICOL statements END otherModules $ 

Top of stack: SEMICOL | Input Token: SEMICOL | Input Token Lexeme: ;
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statements END otherModules $ 

Top of stack: statements | Input Token: FOR | Input Token Lexeme: for
Entry exists in Parse Table
Rule no to use in grammar.txt: 26 | X = 15 | a-NTER = 15 

Pushing these on stack now: 
statements 
statement 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statement statements END otherModules $ 

Top of stack: statement | Input Token: FOR | Input Token Lexeme: for
Entry exists in Parse Table
Rule no to use in grammar.txt: 32 | X = 16 | a-NTER = 15 

Pushing these on stack now: 
iterativeStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
iterativeStmt statements END otherModules $ 

Top of stack: iterativeStmt | Input Token: FOR | Input Token Lexeme: for
Entry exists in Parse Table
Rule no to use in grammar.txt: 102 | X = 55 | a-NTER = 15 

Pushing these on stack now: 
END 
statements 
START 
BC 
range 
IN 
ID 
BO 
FOR 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
FOR BO ID IN range BC START statements END statements END otherModules $ 

Top of stack: FOR | Input Token: FOR | Input Token Lexeme: for
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
BO ID IN range BC START statements END statements END otherModules $ 

Top of stack: BO | Input Token: BO | Input Token Lexeme: (
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID IN range BC START statements END statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: k
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
IN range BC START statements END statements END otherModules $ 

Top of stack: IN | Input Token: IN | Input Token Lexeme: in
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
range BC START statements END statements END otherModules $ 

Top of stack: range | Input Token: NUM | Input Token Lexeme: 1
Entry exists in Parse Table
Rule no to use in grammar.txt: 104 | X = 56 | a-NTER = 20 

Pushing these on stack now: 
NUM 
RANGEOP 
NUM 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
NUM RANGEOP NUM BC START statements END statements END otherModules $ 

Top of stack: NUM | Input Token: NUM | Input Token Lexeme: 1
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
RANGEOP NUM BC START statements END statements END otherModules $ 

Top of stack: RANGEOP | Input Token: RANGEOP | Input Token Lexeme: ..
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
NUM BC START statements END statements END otherModules $ 

Top of stack: NUM | Input Token: NUM | Input Token Lexeme: 10
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
BC START statements END statements END otherModules $ 

Top of stack: BC | Input Token: BC | Input Token Lexeme: )
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
START statements END statements END otherModules $ 

Top of stack: START | Input Token: START | Input Token Lexeme: start
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statements END statements END otherModules $ 

Top of stack: statements | Input Token: ID | Input Token Lexeme: A
Entry exists in Parse Table
Rule no to use in grammar.txt: 26 | X = 15 | a-NTER = 5 

Pushing these on stack now: 
statements 
statement 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statement statements END statements END otherModules $ 

Top of stack: statement | Input Token: ID | Input Token Lexeme: A
Entry exists in Parse Table
Rule no to use in grammar.txt: 29 | X = 16 | a-NTER = 5 

Pushing these on stack now: 
simpleStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
simpleStmt statements END statements END otherModules $ 

Top of stack: simpleStmt | Input Token: ID | Input Token Lexeme: A
Entry exists in Parse Table
Rule no to use in grammar.txt: 42 | X = 21 | a-NTER = 5 

Pushing these on stack now: 
assignmentStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
assignmentStmt statements END statements END otherModules $ 

Top of stack: assignmentStmt | Input Token: ID | Input Token Lexeme: A
Entry exists in Parse Table
Rule no to use in grammar.txt: 44 | X = 22 | a-NTER = 5 

Pushing these on stack now: 
whichStmt 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID whichStmt statements END statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: A
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
whichStmt statements END statements END otherModules $ 

Top of stack: whichStmt | Input Token: SQBO | Input Token Lexeme: [
Entry exists in Parse Table
Rule no to use in grammar.txt: 46 | X = 23 | a-NTER = 17 

Pushing these on stack now: 
lvalueARRStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
lvalueARRStmt statements END statements END otherModules $ 

Top of stack: lvalueARRStmt | Input Token: SQBO | Input Token Lexeme: [
Entry exists in Parse Table
Rule no to use in grammar.txt: 48 | X = 25 | a-NTER = 17 

Pushing these on stack now: 
SEMICOL 
expression 
ASSIGNOP 
SQBC 
index 
SQBO 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SQBO index SQBC ASSIGNOP expression SEMICOL statements END statements END otherModules $ 

Top of stack: SQBO | Input Token: SQBO | Input Token Lexeme: [
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
index SQBC ASSIGNOP expression SEMICOL statements END statements END otherModules $ 

Top of stack: index | Input Token: ID | Input Token Lexeme: k
Entry exists in Parse Table
Rule no to use in grammar.txt: 50 | X = 26 | a-NTER = 5 

Pushing these on stack now: 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID SQBC ASSIGNOP expression SEMICOL statements END statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: k
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SQBC ASSIGNOP expression SEMICOL statements END statements END otherModules $ 

Top of stack: SQBC | Input Token: SQBC | Input Token Lexeme: ]
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ASSIGNOP expression SEMICOL statements END statements END otherModules $ 

Top of stack: ASSIGNOP | Input Token: ASSIGNOP | Input Token Lexeme: :=
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
expression SEMICOL statements END statements END otherModules $ 

Top of stack: expression | Input Token: BO | Input Token Lexeme: (
Entry exists in Parse Table
Rule no to use in grammar.txt: 57 | X = 31 | a-NTER = 23 

Pushing these on stack now: 
arithmeticOrBooleanExpr 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticOrBooleanExpr SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticOrBooleanExpr | Input Token: BO | Input Token Lexeme: (
Entry exists in Parse Table
Rule no to use in grammar.txt: 64 | X = 35 | a-NTER = 23 

Pushing these on stack now: 
arithmeticOrBooleanExpr_again 
recTerm 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
recTerm arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: recTerm | Input Token: BO | Input Token Lexeme: (
Entry exists in Parse Table
Rule no to use in grammar.txt: 67 | X = 37 | a-NTER = 23 

Pushing these on stack now: 
recTerm_again 
arithmeticExpr 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticExpr recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticExpr | Input Token: BO | Input Token Lexeme: (
Entry exists in Parse Table
Rule no to use in grammar.txt: 71 | X = 39 | a-NTER = 23 

Pushing these on stack now: 
arithmeticExpr_again 
term 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term | Input Token: BO | Input Token Lexeme: (
Entry exists in Parse Table
Rule no to use in grammar.txt: 74 | X = 41 | a-NTER = 23 

Pushing these on stack now: 
term_again 
factor 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
factor term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: factor | Input Token: BO | Input Token Lexeme: (
Entry exists in Parse Table
Rule no to use in grammar.txt: 77 | X = 43 | a-NTER = 23 

Pushing these on stack now: 
BC 
arithmeticOrBooleanExpr 
BO 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
BO arithmeticOrBooleanExpr BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: BO | Input Token: BO | Input Token Lexeme: (
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticOrBooleanExpr BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticOrBooleanExpr | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 64 | X = 35 | a-NTER = 5 

Pushing these on stack now: 
arithmeticOrBooleanExpr_again 
recTerm 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
recTerm arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: recTerm | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 67 | X = 37 | a-NTER = 5 

Pushing these on stack now: 
recTerm_again 
arithmeticExpr 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticExpr recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticExpr | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 71 | X = 39 | a-NTER = 5 

Pushing these on stack now: 
arithmeticExpr_again 
term 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 74 | X = 41 | a-NTER = 5 

Pushing these on stack now: 
term_again 
factor 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
factor term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: factor | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 78 | X = 43 | a-NTER = 5 

Pushing these on stack now: 
var_id_num 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
var_id_num term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: var_id_num | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 37 | X = 19 | a-NTER = 5 

Pushing these on stack now: 
whichId 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID whichId term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: num
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
whichId term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: whichId | Input Token: MINUS | Input Token Lexeme: -
Entry exists in Parse Table
Rule no to use in grammar.txt: 41 | X = 20 | a-NTER = 22 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term_again | Input Token: MINUS | Input Token Lexeme: -
Entry exists in Parse Table
Rule no to use in grammar.txt: 76 | X = 42 | a-NTER = 22 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticExpr_again | Input Token: MINUS | Input Token Lexeme: -
Entry exists in Parse Table
Rule no to use in grammar.txt: 72 | X = 40 | a-NTER = 22 

Pushing these on stack now: 
arithmeticExpr_again 
term 
prec2_op 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
prec2_op term arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: prec2_op | Input Token: MINUS | Input Token Lexeme: -
Entry exists in Parse Table
Rule no to use in grammar.txt: 82 | X = 45 | a-NTER = 22 

Pushing these on stack now: 
MINUS 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
MINUS term arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: MINUS | Input Token: MINUS | Input Token Lexeme: -
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term | Input Token: ID | Input Token Lexeme: k
Entry exists in Parse Table
Rule no to use in grammar.txt: 74 | X = 41 | a-NTER = 5 

Pushing these on stack now: 
term_again 
factor 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
factor term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: factor | Input Token: ID | Input Token Lexeme: k
Entry exists in Parse Table
Rule no to use in grammar.txt: 78 | X = 43 | a-NTER = 5 

Pushing these on stack now: 
var_id_num 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
var_id_num term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: var_id_num | Input Token: ID | Input Token Lexeme: k
Entry exists in Parse Table
Rule no to use in grammar.txt: 37 | X = 19 | a-NTER = 5 

Pushing these on stack now: 
whichId 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID whichId term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: k
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
whichId term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: whichId | Input Token: BC | Input Token Lexeme: )
Entry exists in Parse Table
Rule no to use in grammar.txt: 41 | X = 20 | a-NTER = 51 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term_again | Input Token: BC | Input Token Lexeme: )
Entry exists in Parse Table
Rule no to use in grammar.txt: 76 | X = 42 | a-NTER = 51 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticExpr_again | Input Token: BC | Input Token Lexeme: )
Entry exists in Parse Table
Rule no to use in grammar.txt: 73 | X = 40 | a-NTER = 51 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: recTerm_again | Input Token: BC | Input Token Lexeme: )
Entry exists in Parse Table
Rule no to use in grammar.txt: 70 | X = 38 | a-NTER = 51 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticOrBooleanExpr_again | Input Token: BC | Input Token Lexeme: )
Entry exists in Parse Table
Rule no to use in grammar.txt: 66 | X = 36 | a-NTER = 51 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: BC | Input Token: BC | Input Token Lexeme: )
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term_again | Input Token: MUL | Input Token Lexeme: *
Entry exists in Parse Table
Rule no to use in grammar.txt: 75 | X = 42 | a-NTER = 35 

Pushing these on stack now: 
term_again 
factor 
prec1_op 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
prec1_op factor term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: prec1_op | Input Token: MUL | Input Token Lexeme: *
Entry exists in Parse Table
Rule no to use in grammar.txt: 83 | X = 46 | a-NTER = 35 

Pushing these on stack now: 
MUL 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
MUL factor term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: MUL | Input Token: MUL | Input Token Lexeme: *
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
factor term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: factor | Input Token: BO | Input Token Lexeme: (
Entry exists in Parse Table
Rule no to use in grammar.txt: 77 | X = 43 | a-NTER = 23 

Pushing these on stack now: 
BC 
arithmeticOrBooleanExpr 
BO 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
BO arithmeticOrBooleanExpr BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: BO | Input Token: BO | Input Token Lexeme: (
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticOrBooleanExpr BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticOrBooleanExpr | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 64 | X = 35 | a-NTER = 5 

Pushing these on stack now: 
arithmeticOrBooleanExpr_again 
recTerm 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
recTerm arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: recTerm | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 67 | X = 37 | a-NTER = 5 

Pushing these on stack now: 
recTerm_again 
arithmeticExpr 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticExpr recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticExpr | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 71 | X = 39 | a-NTER = 5 

Pushing these on stack now: 
arithmeticExpr_again 
term 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 74 | X = 41 | a-NTER = 5 

Pushing these on stack now: 
term_again 
factor 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
factor term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: factor | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 78 | X = 43 | a-NTER = 5 

Pushing these on stack now: 
var_id_num 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
var_id_num term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: var_id_num | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 37 | X = 19 | a-NTER = 5 

Pushing these on stack now: 
whichId 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID whichId term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: num
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
whichId term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: whichId | Input Token: PLUS | Input Token Lexeme: +
Entry exists in Parse Table
Rule no to use in grammar.txt: 41 | X = 20 | a-NTER = 24 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term_again | Input Token: PLUS | Input Token Lexeme: +
Entry exists in Parse Table
Rule no to use in grammar.txt: 76 | X = 42 | a-NTER = 24 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticExpr_again | Input Token: PLUS | Input Token Lexeme: +
Entry exists in Parse Table
Rule no to use in grammar.txt: 72 | X = 40 | a-NTER = 24 

Pushing these on stack now: 
arithmeticExpr_again 
term 
prec2_op 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
prec2_op term arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: prec2_op | Input Token: PLUS | Input Token Lexeme: +
Entry exists in Parse Table
Rule no to use in grammar.txt: 81 | X = 45 | a-NTER = 24 

Pushing these on stack now: 
PLUS 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
PLUS term arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: PLUS | Input Token: PLUS | Input Token Lexeme: +
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term | Input Token: ID | Input Token Lexeme: k
Entry exists in Parse Table
Rule no to use in grammar.txt: 74 | X = 41 | a-NTER = 5 

Pushing these on stack now: 
term_again 
factor 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
factor term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: factor | Input Token: ID | Input Token Lexeme: k
Entry exists in Parse Table
Rule no to use in grammar.txt: 78 | X = 43 | a-NTER = 5 

Pushing these on stack now: 
var_id_num 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
var_id_num term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: var_id_num | Input Token: ID | Input Token Lexeme: k
Entry exists in Parse Table
Rule no to use in grammar.txt: 37 | X = 19 | a-NTER = 5 

Pushing these on stack now: 
whichId 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID whichId term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: k
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
whichId term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: whichId | Input Token: BC | Input Token Lexeme: )
Entry exists in Parse Table
Rule no to use in grammar.txt: 41 | X = 20 | a-NTER = 51 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term_again | Input Token: BC | Input Token Lexeme: )
Entry exists in Parse Table
Rule no to use in grammar.txt: 76 | X = 42 | a-NTER = 51 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticExpr_again | Input Token: BC | Input Token Lexeme: )
Entry exists in Parse Table
Rule no to use in grammar.txt: 73 | X = 40 | a-NTER = 51 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
recTerm_again arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: recTerm_again | Input Token: BC | Input Token Lexeme: )
Entry exists in Parse Table
Rule no to use in grammar.txt: 70 | X = 38 | a-NTER = 51 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticOrBooleanExpr_again BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticOrBooleanExpr_again | Input Token: BC | Input Token Lexeme: )
Entry exists in Parse Table
Rule no to use in grammar.txt: 66 | X = 36 | a-NTER = 51 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
BC term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: BC | Input Token: BC | Input Token Lexeme: )
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
term_again arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: term_again | Input Token: SEMICOL | Input Token Lexeme: ;
Entry exists in Parse Table
Rule no to use in grammar.txt: 76 | X = 42 | a-NTER = 40 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticExpr_again recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticExpr_again | Input Token: SEMICOL | Input Token Lexeme: ;
Entry exists in Parse Table
Rule no to use in grammar.txt: 73 | X = 40 | a-NTER = 40 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
recTerm_again arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: recTerm_again | Input Token: SEMICOL | Input Token Lexeme: ;
Entry exists in Parse Table
Rule no to use in grammar.txt: 70 | X = 38 | a-NTER = 40 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
arithmeticOrBooleanExpr_again SEMICOL statements END statements END otherModules $ 

Top of stack: arithmeticOrBooleanExpr_again | Input Token: SEMICOL | Input Token Lexeme: ;
Entry exists in Parse Table
Rule no to use in grammar.txt: 66 | X = 36 | a-NTER = 40 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SEMICOL statements END statements END otherModules $ 

Top of stack: SEMICOL | Input Token: SEMICOL | Input Token Lexeme: ;
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statements END statements END otherModules $ 

Top of stack: statements | Input Token: PRINT | Input Token Lexeme: print
Entry exists in Parse Table
Rule no to use in grammar.txt: 26 | X = 15 | a-NTER = 13 

Pushing these on stack now: 
statements 
statement 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statement statements END statements END otherModules $ 

Top of stack: statement | Input Token: PRINT | Input Token Lexeme: print
Entry exists in Parse Table
Rule no to use in grammar.txt: 28 | X = 16 | a-NTER = 13 

Pushing these on stack now: 
ioStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ioStmt statements END statements END otherModules $ 

Top of stack: ioStmt | Input Token: PRINT | Input Token Lexeme: print
Entry exists in Parse Table
Rule no to use in grammar.txt: 34 | X = 17 | a-NTER = 13 

Pushing these on stack now: 
SEMICOL 
BC 
var 
BO 
PRINT 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
PRINT BO var BC SEMICOL statements END statements END otherModules $ 

Top of stack: PRINT | Input Token: PRINT | Input Token Lexeme: print
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
BO var BC SEMICOL statements END statements END otherModules $ 

Top of stack: BO | Input Token: BO | Input Token Lexeme: (
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
var BC SEMICOL statements END statements END otherModules $ 

Top of stack: var | Input Token: ID | Input Token Lexeme: A
Entry exists in Parse Table
Rule no to use in grammar.txt: 35 | X = 18 | a-NTER = 5 

Pushing these on stack now: 
var_id_num 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
var_id_num BC SEMICOL statements END statements END otherModules $ 

Top of stack: var_id_num | Input Token: ID | Input Token Lexeme: A
Entry exists in Parse Table
Rule no to use in grammar.txt: 37 | X = 19 | a-NTER = 5 

Pushing these on stack now: 
whichId 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID whichId BC SEMICOL statements END statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: A
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
whichId BC SEMICOL statements END statements END otherModules $ 

Top of stack: whichId | Input Token: SQBO | Input Token Lexeme: [
Entry exists in Parse Table
Rule no to use in grammar.txt: 40 | X = 20 | a-NTER = 17 

Pushing these on stack now: 
SQBC 
index 
SQBO 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SQBO index SQBC BC SEMICOL statements END statements END otherModules $ 

Top of stack: SQBO | Input Token: SQBO | Input Token Lexeme: [
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
index SQBC BC SEMICOL statements END statements END otherModules $ 

Top of stack: index | Input Token: ID | Input Token Lexeme: k
Entry exists in Parse Table
Rule no to use in grammar.txt: 50 | X = 26 | a-NTER = 5 

Pushing these on stack now: 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID SQBC BC SEMICOL statements END statements END otherModules $ 

Top of stack: ID | Input Token: ID | Input Token Lexeme: k
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SQBC BC SEMICOL statements END statements END otherModules $ 

Top of stack: SQBC | Input Token: SQBC | Input Token Lexeme: ]
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
BC SEMICOL statements END statements END otherModules $ 

Top of stack: BC | Input Token: BC | Input Token Lexeme: )
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
SEMICOL statements END statements END otherModules $ 

Top of stack: SEMICOL | Input Token: SEMICOL | Input Token Lexeme: ;
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statements END statements END otherModules $ 

Top of stack: statements | Input Token: END | Input Token Lexeme: end
Entry exists in Parse Table
Rule no to use in grammar.txt: 27 | X = 15 | a-NTER = 50 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
END statements END otherModules $ 

Top of stack: END | Input Token: END | Input Token Lexeme: end
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statements END otherModules $ 

Top of stack: statements | Input Token: END | Input Token Lexeme: end
Entry exists in Parse Table
Rule no to use in grammar.txt: 27 | X = 15 | a-NTER = 50 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
END otherModules $ 

Top of stack: END | Input Token: END | Input Token Lexeme: end
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
otherModules $ 


otherModules not used hence popping it!


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
$ 

	Parsing successfully for input file....!