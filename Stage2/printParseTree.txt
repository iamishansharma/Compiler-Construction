
Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
program $ 

Top of stack: program | Input Token: DRIVERDEF | Input Token Lexeme: <<<
Entry exists in Parse Table
Rule no to use in grammar.txt: 1 

Pushing these on stack now: 
otherModules 
driverModule 
otherModules 
moduleDeclarations 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
moduleDeclarations otherModules driverModule otherModules $ 

Top of stack: moduleDeclarations | Input Token: DRIVERDEF | Input Token Lexeme: <<<
Entry exists in Parse Table
Rule no to use in grammar.txt: 3 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
otherModules driverModule otherModules $ 

Top of stack: otherModules | Input Token: DRIVERDEF | Input Token Lexeme: <<<
Entry exists in Parse Table
Rule no to use in grammar.txt: 6 

Pushing these on stack now: 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
driverModule otherModules $ 

Top of stack: driverModule | Input Token: DRIVERDEF | Input Token Lexeme: <<<
Entry exists in Parse Table
Rule no to use in grammar.txt: 7 

Pushing these on stack now: 
moduleDef 
DRIVERENDDEF 
PROGRAM 
DRIVER 
DRIVERDEF 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
DRIVERDEF DRIVER PROGRAM DRIVERENDDEF moduleDef otherModules $ 

Top of stack: DRIVERDEF | Input Token: DRIVERDEF | Input Token Lexeme: <<<
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
DRIVER PROGRAM DRIVERENDDEF moduleDef otherModules $ 

Top of stack: DRIVER | Input Token: DRIVER | Input Token Lexeme: driver
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
PROGRAM DRIVERENDDEF moduleDef otherModules $ 

Top of stack: PROGRAM | Input Token: PROGRAM | Input Token Lexeme: program
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
DRIVERENDDEF moduleDef otherModules $ 

Top of stack: DRIVERENDDEF | Input Token: DRIVERENDDEF | Input Token Lexeme: >>>
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
moduleDef otherModules $ 

Top of stack: moduleDef | Input Token: START | Input Token Lexeme: start
Entry exists in Parse Table
Rule no to use in grammar.txt: 25 

Pushing these on stack now: 
END 
statements 
START 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
START statements END otherModules $ 

Top of stack: START | Input Token: START | Input Token Lexeme: start
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statements END otherModules $ 

Top of stack: statements | Input Token: DECLARE | Input Token Lexeme: declare
Entry exists in Parse Table
Rule no to use in grammar.txt: 26 

Pushing these on stack now: 
statements 
statement 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
statement statements END otherModules $ 

Top of stack: statement | Input Token: DECLARE | Input Token Lexeme: declare
Entry exists in Parse Table
Rule no to use in grammar.txt: 30 

Pushing these on stack now: 
declareStmt 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
declareStmt statements END otherModules $ 

Top of stack: declareStmt | Input Token: DECLARE | Input Token Lexeme: declare
Entry exists in Parse Table
Rule no to use in grammar.txt: 93 

Pushing these on stack now: 
SEMICOL 
dataType 
COLON 
idList 
DECLARE 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
DECLARE idList COLON dataType SEMICOL statements END otherModules $ 

Top of stack: DECLARE | Input Token: DECLARE | Input Token Lexeme: declare
ACTION: Popping top of stack because same terminal found at input.


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
idList COLON dataType SEMICOL statements END otherModules $ 

Top of stack: idList | Input Token: ID | Input Token Lexeme: num
Entry exists in Parse Table
Rule no to use in grammar.txt: 54 

Pushing these on stack now: 
idList_again 
ID 


Stack (TOP OF STACK IS LEFT MOST ELEMENT: 
ID idList_again COLON dataType SEMICOL statements END otherModules $ 

Top of stack: ID | Input Token: I